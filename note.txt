main_sfm.cpp


read file


        std::string sourceUri = app.findSampleFilePath("sfm/parking_sfm.mp4");
        std::string configFile = app.findSampleFilePath("sfm/sfm_config.ini");



process


nvxio::createDefaultFrameSource(context, sourceUri));






Framesource.cpp


cpp


vx_image loadImageFromFile(vx_context context, const std::string& fileName, vx_df_image format)



        /** \brief Indicates the operation succeeded. */
        APP_EXIT_CODE_SUCCESS               = 0,
        /** \brief Indicates a generic error code; this code is used when no other code describes the error. */
        APP_EXIT_CODE_ERROR                 = 1,
        /** \brief Indicates an internal or implicit allocation failure. */
        APP_EXIT_CODE_NO_MEMORY             = 2,
        /** \brief Indicates the resource (file, etc.) cannot be acquired. */
        APP_EXIT_CODE_NO_RESOURCE           = 3,
        /** \brief Indicates the framesource exists but cannot be read. */
        APP_EXIT_CODE_NO_FRAMESOURCE        = 4,
        /** \brief Indicates the render cannot be created. */
        APP_EXIT_CODE_NO_RENDER             = 5,
        /** \brief Indicates the supplied graph failed verification. */
        APP_EXIT_CODE_INVALID_GRAPH         = 6,
        /** \brief Indicates the parameter provided does not match the algorithm's possible values or
         * a validation procedure failure. */
        APP_EXIT_CODE_INVALID_VALUE         = 7,
        /** \brief Indicates the parameter provided is too big or too small in dimension, or
         * is not of even size. */
        APP_EXIT_CODE_INVALID_DIMENSIONS    = 8,
        /** \brief Indicates the parameter provided is in an invalid format. */
        APP_EXIT_CODE_INVALID_FORMAT        = 9,
        /** \brief Indicates the object cannot be created. */
        APP_EXIT_CODE_CAN_NOT_CREATE        = 10,
        // add new codes here




if (!source || !source->open())
{
     std::cout << "Can't open source file: " << sourceUri << std::endl;
     int errno=3;
     fprintf(stderr, "errno = %d \n", errno);
     return nvxio::Application::APP_EXIT_CODE_NO_RESOURCE;
}





std::unique_ptr<nvxio::FrameSource> source(
      nvxio::createDefaultFrameSource(context, sourceUri));





vx_image loadImageFromFile(vx_context context, const std::string& fileName, vx_df_image format)
{
    auto frameSource = createDefaultFrameSource(context, fileName);
    if (!frameSource)
    {
        NVXIO_THROW_EXCEPTION("Cannot create frame source for file: " << fileName);
    }

    if (frameSource->getSourceType() != FrameSource::SINGLE_IMAGE_SOURCE)
    {
        NVXIO_THROW_EXCEPTION("Expected " << fileName << " to be an image");
    }

    auto frameConfig = frameSource->getConfiguration();
    frameConfig.format = format;
    frameSource->setConfiguration(frameConfig);

    if (!frameSource->open())
    {
        NVXIO_THROW_EXCEPTION("Cannot open file: " << fileName);
    }

    frameConfig = frameSource->getConfiguration();

    vx_image image = vxCreateImage(context, frameConfig.frameWidth, frameConfig.frameHeight, format);
    NVXIO_CHECK_REFERENCE(image);

    if (frameSource->fetch(image, TIMEOUT_INFINITE) != FrameSource::OK)
    {
        vxReleaseImage(&image);
        NVXIO_THROW_EXCEPTION("Cannot fetch a frame from file: " << fileName);
    }

    return image;
}


int haha=3;
fprintf(stderr, "errno = %d \n", haha);


#ifdef USE_OPENCV

framesource.cpp


